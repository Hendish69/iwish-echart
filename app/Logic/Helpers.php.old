<?php 
use \Illuminate\Support\Facades\Request as Req;
use Illuminate\Support\Facades\DB;
if(!function_exists('toWgs')){
    function toWgs($dec,$type) {
    
    if ($type=='LAT'){
        if ( $dec>0){
            $head='N';
        }else{
            $head='S';
            $dec *=-1;
        }
    }else{
        if ( $dec>0){
            $head='E';
        }else{
            $head='W';
            $dec *=-1;
        }
    }
    $vars = explode('.', $dec);
    $deg = $vars[0];
    // var_dump(sprintf('%03d',$deg));
    $tempma = '0.'. $vars[1];
    // var_dump($dec,$deg,$tempma);
    $tempma = $tempma * 3600;
    // var_dump($tempma);
    $min1 = floor($tempma / 60);
    $min=sprintf('%02d',$min1);
    
    $sec1 = $tempma - ($min1 * 60);
    //  var_dump(number_format($sec1,2));
    $det = explode('.', number_format($sec1,2));
    $sec=sprintf('%02d',$sec1);
    if ($type=='LAT'){
        $deg=sprintf('%02d',$deg);
    }
    if ($type=='LON'){
        $deg=sprintf('%03d',$deg);
    }
    
    // return $deg.$min.$sec.$det[1].$head;
    return $deg.$min.$sec.'.'.$det[1].$head;
    
    // return array('deg' => $deg, 'min' => $min, 'sec' => $sec);
    }
}
if(!function_exists('toDecimal')){
    function toDecimal($corvalue) {
    
        $head;
        $mark;
        $deg;
        $Min;
        $sec;
        
        $reslt;
        $head = substr($corvalue,strlen($corvalue)-1);
        if ($head == "E" || $head == "N") {
            $mark = 1;
        } else if ($head == "W" || $head == "S") {
            $mark = -1;
        }
       
        if ($head == "E" || $head == "W") {
            $deg = (int)(substr($corvalue,0, 3));
            $Min = (int)( substr($corvalue, 3, 2 ) );
            if (substr($corvalue,5, 1) == ".") {
                $sec = (int)("0." + substr($corvalue,6, (strlen($corvalue) - 7))) * 60;
            } else {
                if (strlen($corvalue) < 10) {
                    $sec = (int)(substr($corvalue,5, 2));
                } else {
                    $sec = (float)(substr($corvalue,5, 4))/100;
                }
            }
            $afS =  $sec / 60;

        } else if ($head == "N" || $head == "S") {
            $deg = (int)(substr($corvalue,0, 2));
            $Min = (int)(substr($corvalue,2, 2));
            if (substr($corvalue,4, 1) == ".") {
                $sec = (int)("0." + substr($corvalue,5, (strlen($corvalue) - 5))) * 60;
            } else {
                if (strlen($corvalue) < 9) {
                    $sec = (int)(substr($corvalue,4,2));
                } else {
                    $sec = (float)(substr($corvalue,4, 4))/100;
                }
            }
            $afS =  $sec / 60;
        }
   
    $minsec = ( $Min + $afS ) / 60;
   
    $reslt = ($deg + $minsec) * $mark;
    return $reslt;
    }
}
if(!function_exists('Airspacefreq')){
    function Airspacefreq($freq,$unit,$real=null){
    // dd($freq,$unit);
    if ( $unit == 'V' ) {
        if ( $real == null ) {
            $f= ($freq/1000000).' MHz';
        } else {
            $f = $freq / 1000000;
        }
    } else {
        if ( $real == null ) {
            $f= ($freq/1000).' kHz';
        } else {
            $f = $freq / 1000;
        }
    }
                // dd($f);
    return $f;
    }
}
if(!function_exists('FreqFormat')){
    function FreqFormat( $freq, $navtype, $usefor ) {

    if ( $freq == '' ) {
        $rslt = 'NIL';
    } else if ( $navtype == '3' || $navtype == '9' ) {
        $rslt = $freq;
    } else {
        $rplc = ["M", "K", " "];
        $frq = str_replace($rplc, '', $freq);
        switch ( $navtype ) {
            case '5':
            case '7':
            case '10':
                if ( $frq >= 100000 ) {
                    $rslt = $frq / 1000;
                } else {
                    $rslt = $frq;
                }
                if ( $usefor == 'DATA' ) {
                    $rslt =number_format($rslt,2);//numeral($rslt).format('0.00');
                } else {
                    $rslt =number_format($rslt,0).'kHz';
                }
                break;
            default:
            // var_dump($frq);
                if ($frq < 200){
                    $rslt =$frq.'MHz';
                }else{

                    if ( $frq >= 1000000 ) {
                        if ( $usefor == 'DATA' ) {
                            $rslt =number_format($frq / 10000,2); //numeral($frq / 10000).format('0.00') //format( "####.00", $frq / 10000 )
                        } else {
                            $rslt = number_format($frq / 10000,2).'MHz';//numeral($frq / 10000).format('0.0[00]') + 'MHz' //format( "####.0##", $frq / 10000 ) + 'MHz'
                        }
                    } else if ( $frq < 1000000 && $frq > 100000 ) {
                        if ( $usefor == 'DATA' ) {
                            $rslt =number_format($frq / 10000,2);// numeral($frq / 1000).format('0.00') //format( "####.00", $frq / 1000 )
                        } else {
                            $rslt =number_format($frq / 10000,2).'MHz'; //numeral($frq / 1000).format('0.0[00]') + 'MHz' // format( "####.###", $frq / 1000 ) + 'MHz'
                        }
                    } else {
                        if ( $usefor == 'DATA' ) {
                            $rslt = number_format($frq / 10000,2);//numeral($frq).format('0.00') //format( "###.00", $frq )
                        } else {
                            $rslt =number_format($frq / 10000,2).'MHz';// numeral($frq).format('0.0[00]')+ 'MHz' //format( "###.0##", $frq ) + 'MHz'
                        }
                    }
                }
                break;
        }
    }
    // console.log($rslt);
    return $rslt;
    }
}
if(!function_exists('getDataApi')){
    function getDataApi($originalInput, $url, $method='GET'){
        $request = Req::create($url);
        Req::replace($request->input());
        $instance = json_decode(Route::dispatch($request)->getContent());
        Req::replace($originalInput);
        if($instance) return $instance->data;
    }
}
if(!function_exists('ConvertTime')){
    function ConvertTime($data){
        $hrs=floor($data / 3600);
        $min= floor(($data / 60) % 60);
        $seconds = $data % 60;
        if ($hrs > 24){
            $day=floor($hrs / 24) ;
            $hrs = $hrs % 24;
            return $day .' days '.$hrs.' hour '.$min.' minutes '.$seconds.' seconds';
        }else{
            return $hrs.' hour '.$min.' minutes '.$seconds.' seconds';
        }
   }
}
if(!function_exists('listUser')){
    function listUser($reff=''){  
        $sql = "SELECT *, A.id as u_id FROM users A 
                  LEFT JOIN org B ON A.org_id=B.org_id
                  LEFT JOIN country C ON A.user_country=C.ident
                WHERE A.user_status='1' AND A.email != '' ORDER BY A.org_id, A.name";
        $users =DB::select(DB::raw($sql));
        // dd($users);
        $orgname="";
        $option=""; 
        foreach($users as $row) {
            $selected = '';
            if($row->org_name_en!=$orgname){
               if($orgname==''){
                  $option.='<optgroup label="'.$row->org_name_en.'">';
               }else{
                  $option.='</optgroup><optgroup label="'.$row->org_name_en.'">';
               }
            }
            if($row->u_id==$reff)
               $selected = 'selected="selected"';

            $option .='<option '.$selected.' contact="<b>Mobile :</b><br>'.$row->user_phone.'<br><b>Email &nbsp; :</b><br>'.$row->email.'" designation="'.($row->user_position!='' ? $row->user_position.'<br>' : '').($row->user_unit!='' ? $row->user_unit.'<br>' : '').($row->org_name_en!='' ? $row->org_name_en.'<br>' : '').($row->country_name!='' ? '<b>'.strtoupper($row->country_name).'</b><br>' : '').'" value="'.$row->u_id.'"> &nbsp;  &nbsp;  &nbsp; '.$row->name.'</option>';
            $orgname = $row->org_name_en;
         }
         return $option;
          
      }
}
 
if(!function_exists('clearStr')){
    function clearStr($str, $slash=true){
        $text = preg_replace("/[\r\n]+/", " ", trim($str));
        $text = nl2br($text);
        if($slash){
            $text = addslashes($text);
        }
        return $text;
    }
}
if(!function_exists('remSpecialChar')){
    function remSpecialChar($str){
        return preg_replace("~[^A-Za-z0-9!@#$%^&*()_+-={}|<>?\;,./ :]~i", "", $str); 
    }
}
 
if(!function_exists('getdistance')){     
    function getdistance( $latitude1, $longitude1, $latitude2, $longitude2 ) {
        $hasil = '';
        if (is_nan($latitude1)==true || is_nan($longitude1)==true || is_nan($latitude2)==true || is_nan($longitude2)==true ) {
            echo "<script> console.log( 'getdist cannot proses ', ".$latitude1.",".$longitude1.",".$latitude2.",".$longitude2.")</script>";
        } else {
            $newVal = new stdClass();//create a new
            $newVal->a = $longitude1;
            $newVal->b = $latitude1;
            $newVal->c = $longitude2;
            $newVal->d = $latitude2;
            $val = $newVal;
            $hhs = array();
            $kk = '';
            $rslt = array();
            $rslt = Getbearing( $latitude1, $longitude1, $latitude2, $longitude2 );
        }
        return $rslt;
    }
}
if(!function_exists('Getbearing')){
    function Getbearing( $latitude1, $longitude1, $latitude2, $longitude2 ){
        $R = 6371.01; //' // earth's mean radius in km
        $nm  = 0.5399568035;
        $a  = 6378137;
        $b  = 6356752.314245;
        $f  = 1 / 298.257223563 ;
        // var f = 1 / 298.257223563;
        // var f = 0.00335281068118 ;0.00335281066474

        $epoch = date('Y-m-d');
        // MV.GetMagvar( longitude1, latitude1, epoch );
        $mv = GetMagvar( $longitude1, $latitude1, $epoch );
        // console.log('hasil magvar', mv );
        $mgvar1 = $mv->dec;
        // console.log(MV.result)
        $mv = GetMagvar( $longitude2, $latitude2, $epoch );
        $mgvar2 = $mv->dec;
        // console.log(MV.result)
        // console.log(mgvar1 + '  ' + mgvar1)
        $trkoutT; $trkoutM; $trkinT; $trkinM; $midX; $midY; $trackoutM; $trackinM; $trackoutT; $trackinT;

        for ( $i = 0; $i < 2; $i++ ) {
            $lat1 = deg2rad( $latitude1 );
            $lat2 = deg2rad( $latitude2 );
            $lon1 = deg2rad( $longitude1 );
            $lon2 = deg2rad( $longitude2 );
            if ( $i == 1 ) {
                $lat1 = deg2rad( $latitude2 );
                $lat2 = deg2rad( $latitude1 );
                $lon1 = deg2rad( $longitude2 );
                $lon2 = deg2rad( $longitude1 );
            }
            $dLat; $dLon;
            if ( $lat1 > $lat2 ) {
                $dLat = $lat1 - $lat2;  // deg2rad below
            } else {
                $dLat =$lat2 - $lat1;  // deg2rad below
            }
            if ( $lon1 > $lon2 ) {
                $dLon = $lon1-$lon2; 
            } else {
                $dLon = $lon2-$lon1; 
            }
            
            $bx = cos( $lat2 ) * cos( $L );
            $by = cos( $lat2 ) * sin( $L );
            $lat3 = atan2( sin( $lat1 ) + sin( $lat2 ), sqrt( ( cos( $lat1 ) + $bx ) * ( cos( $lat1 ) + $bx ) + $by * $by ) );
            $lon3 = $lon1 + atan2( $by, cos( $lat1 ) + $bx );
            $midX = rad2deg( $lon3 );
            $midY = rad2deg( $lat3 );

            $L = $lon2 - $lon1;
            $iterations = 0;

            $tanU1 = ( 1 - $f ) * tan( $lat1 );
            $cosU1 = 1 / sqrt( ( 1 + $tanU1 * $tanU1 ) );
            $sinU1 = $tanU1 * $cosU1;
            $tanU2 = ( 1 - $f ) * tan( $lat2 );
            $cosU2 = 1 / sqrt( ( 1 + $tanU2 * $tanU2 ) );
            $sinU2 = $tanU2 * $cosU2;

            $sinλ; $cosλ; $sinSqσ; $sinσ; $cosσ; $σ; $sinα; $cosSqα; $cos2σM; $C;
            $λ = $L;
            $λ1 = 0.0;

            while ( (abs( $λ - $λ1 ) > 0.000000000001) && ($iterations++ < 200) ) {
                $sinλ = sin( $λ );
                $cosλ = cos( $λ );
                $sinSqσ = ( $cosU2 * $sinλ ) * ( $cosU2 * $sinλ ) + ( $cosU1 * $sinU2 - $sinU1 * $cosU2 * $cosλ ) * ( $cosU1 * $sinU2 - $sinU1 * $cosU2 * $cosλ );
                $sinσ = sqrt( $sinSqσ );
                // '   MsgBox(sinσ)
                // '  If (sinσ = 0) Then Return 0 '  // co-incident points
                $cosσ = $sinU1 * $sinU2 + $cosU1 * $cosU2 * $cosλ;
                $σ = atan2($sinσ, $cosσ); //distance
                $sinα = $cosU1 * $cosU2 * $sinλ / $sinσ;
                $cosSqα = 1 - $sinα * $sinα;
                $cos2σM = $cosσ - 2 * $sinU1 * $sinU2 / $cosSqα;
                if ( is_nan( $cos2σM ) ) {
                    $cos2σM = 0;
                }
                // ' // equatorial line: cosSqα=0 (§6)
                $C = $f / 16 * $cosSqα * ( 4 + $f * ( 4 - 3 * $cosSqα ) );
                $λ1 = $λ;
                $λ = $L + ( 1 - $C ) * $f * $sinα * ( $σ + $C * $sinσ * ( $cos2σM + $C * $cosσ * ( -1 + 2 * $cos2σM * $cos2σM ) ) );
            }
            // var isNaN = function(value) {
            //     return Number.isNaN(Number(value));
            //     }
            if ( $iterations >= 200 ) {
                echo '<script> alert( "Formula failed to converge" )</script>';
            }
            $uSq = $cosSqα * ($a * $a - $b * $b) / ($b * $b);
            $AA = 1 + $uSq / 16384 * ( 4096 + $uSq * ( -768 + $uSq * ( 320 - 175 * $uSq ) ) );
            $BB = $uSq / 1024 * ( 256 + $uSq * ( -128 + $uSq * ( 74 - 47 * $uSq ) ) );
            $Δσ = $BB * $sinσ * ( $cos2σM + $BB / 4 * ( $cosσ * ( -1 + 2 * $cos2σM * $cos2σM ) - $BB / 6 * $cos2σM * ( -3 + 4 * $sinσ * $sinσ ) * ( -3 + 4 * $cos2σM * $cos2σM ) ) );

            $s  = $b * $AA * ($σ - $Δσ);
        //    console.log('TESTTTT',s,σ)
            $α1 = atan2( $cosU2 * $sinλ, $cosU1 * $sinU2 - $sinU1 * $cosU2 * $cosλ );
            $α2 = atan2( $cosU1 * $sinλ, - $sinU1 * $cosU2 + $cosU1 * $sinU2 * $cosλ );

            $α1 = rad2deg( ( $α1 + 2 * pi() ) % ( 2 * pi() ) ); // normalise to 0..360
            $α2 = rad2deg( ( $α2 + 2 * pi() ) % ( 2 * pi() ) ); // normalise to 0..360
            // console.log(α1 + '  ' + α2)
            if ( $lon2 == $lon1 ) {
                if ( $lat1 > $lat2 ) {
                    $α1 = $α2;
                }
            }

            if ( $i == 0 ) {
                // format("####.0##",frq/10000)
                // console.log(α1 , ' track out ' , α2 , ' i ' , i )
                $trkoutT = $α1;
                $trackoutT = number_format( ( round( $trkoutT * 100 ) / 100) , 2,'.','' );
                $trkoutM = $trkoutT - $mgvar1;
                if ( $trkoutM < 0 ) {        
                    $trkoutM = ( 360 + $trkoutT ) - $mgvar1;
                }
                $trackoutM =number_format( ( round( $trkoutM * 100 ) / 100), 2,'.','' ); //format( "000", trkoutM.toFixed() )
            } else {
                // console.log(α1 , ' track in ' , α2 , ' i ' , i )
                $trkinT = $α2;
                $trackinT =number_format( ( round( $trkinT * 100 ) / 100 ), 2,'.','' );
                $trkinM = $trkinT - $mgvar2;
                if ( $trkinM < 0 ) {
                    $trkinM = ( 360 + $trkinT ) - $mgvar2;
                }
                $trackinM = number_format( ( round( $trkinM * 100 ) / 100 ),2,'.','' );//format( "000", trkinM.toFixed() )
            }
        }
        $d =  m2Nm($s);
        $dsnm = number_format($d ,2,'.','');
        $dist = round($s);
        // console.log( ' hasil  ' ,dist,s,trackoutT,trackoutM,trackinT,trackinM)
        $ret = (object)[
            'TrackOutTrue' => $trackoutT,
            'TrackOutMag' => $trackoutM,
            'TrackInTrue' => $trackinT,
            'TrackInMag' => $trackinM,
            'TrackOutReal' => $trkoutT,
            'TrackOutMagReal' => $trkoutM,
            'TrackInReal' => $trkinT,
            'TrackInMagReal' => $trkinM,
            'Midlat' => $midY,
            'Midlon' => $midX,
            'DistinNM' => $dsnm,
            'Distance' => $dist,
            'DistanceReal' => $d,
            'DistinMeter' => $s
        ];
        return  $ret;
    }
}

if(!function_exists('GetMagvar')){ 
    function GetMagvar(&...$args) {
        $result = array();
        $lat; $lon; $tgl; $alt;

        if ( is_object($args[0]) ) {
            $lat = $args[ 0 ][ 1 ];
            $lon = $args[ 0 ][ 0 ];
            $alt = $args[ 2 ];
            $tgl = $args[ 1 ];
        } else if ( is_numeric($args[ 0 ])  && is_numeric($args[ 1 ]) ) {
            $lat = $args[ 1 ];
            $lon = $args[ 0 ];
            $alt = $args[ 3 ];
            $tgl = $args[ 2 ];
        }
        $time=strtotime($tgl);
        $yr=(int)date("Y",$time);
        
        $protocol = ((!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] != 'off') || $_SERVER['SERVER_PORT'] == 443) ? "https://" : "http://";
        if (strpos($_SERVER['HTTP_HOST'], 'iwish.dephub.go.id') !== false) {
            $protocol ='https://';  //fixed some bugs
        }
        $url = $protocol . $_SERVER['HTTP_HOST'];

        $path= $url;
        
        $coffile = '/images/wmm/WMM2020.COF';
        if ( ($yr > 2014) && ($yr < 2020) ) {

            $coffile = '/images/wmm/WMM2015.COF';
        } else if ( $yr < 2015 ) {
            $coffile = '/images/wmm/WMM2010.COF';

        }

        $cof = file( $path . $coffile );
        $newGeomag = new Geomag( $cof );
        $result = $newGeomag->mag($lat, $lon, $alt, $tgl);
        // $json_string = json_encode($result, JSON_PRETTY_PRINT);
        // echo $json_string;die;   
        return $result;
    }
}
if(!function_exists('syncXHR')){
    function syncXHR( $url ) {
        $ch = curl_init();
        $data = '';
        // Set curl options
        curl_setopt_array($ch, array(
            CURLOPT_RETURNTRANSFER => 1, // Return information from server
            CURLOPT_URL => $url,
            CURLOPT_POST => 1, // Normal HTTP post 
            CURLOPT_POSTFIELDS => $data
        ));

        // Execute curl and return result to $response
        $response = curl_exec($ch);
        // Close request
        curl_close($ch);

        return $response;
    }
}
 
class Geomag {
    public $wmm;
    public $maxord = 12;
    public $a = 6378.137; // WGS 1984 Equatorial axis (km)
    public $b = 6356.7523142; // WGS 1984 Polar axis (km)
    public $re = 6371.2;
    public $a2 ;
    public $b2 ;
    public $c2 ;
    public $a4 ;
    public $b4 ;
    public $c4 ;
    public $z = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
    public $unnormalizedWMM;

    function __construct($model=null){
        $this->a2 = $this->a * $this->a;
        $this->b2 = $this->b * $this->b;
        $this->c2 = $this->a2 - $this->b2;
        $this->a4 = $this->a2 * $this->a2;
        $this->b4 = $this->b2 * $this->b2;
        $this->c4 = $this->a4 - $this->b4;
         if ( $model !== null ) { // initialize
            if ( is_array($model)) { // WMM.COF file
                $this->parseCof( $model );
                $this->unnormalize( $this->wmm );
            } else if ( is_object($model) ) { // unnorm obj
                $this->setUnnorm( $model );
            } else {
                throw new Exception( "Invalid argument type" );
            }
        }
    }   


    function parseCof( $cof ) {
        $ret = '';
        $callwmm =  (function() use ($cof) {
            $modelLines = $cof;
                $cwmm = array();
                $i; $vals; $epoch; $model; $modelDate;
                foreach ($modelLines as  $i => $val) {
                    if ( property_exists( (object) $modelLines, $i ) ) {
                        $vals =  preg_split('/\s+/', trim($modelLines[ $i ]));
                        if ( count($vals) == 3 ) {
                            $epoch = floatval( $vals[ 0 ] );
                            $model = $vals[ 1 ];
                            $modelDate = $vals[ 2 ];
                        } else if ( count($vals) == 6 ) {
                            array_push($cwmm , (object)[
                                'n'   => intval($vals[ 0 ], 10),
                                'm'    => intval($vals[ 1 ], 10),
                                'gnm'  => floatval($vals[ 2 ]),
                                'hnm'  => floatval($vals[ 3 ]),
                                'dgnm' => floatval($vals[ 4 ]),
                                'dhnm' => floatval($vals[ 5 ]),
                            ]);
                        }
                    }      
                } 
                $ret = (object)[
                    'epoch' => $epoch,
                    'model' => $model,
                    'modelDate' => $modelDate,
                    'wmm' => $cwmm
                ];
            return $ret;
        });     
        $ret = $callwmm();
        $this->wmm = $ret;  
    }
    function unnormalize( $wmm ) {
 
            $i; $j; $m; $n; $D2; $flnmj;
            $z = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
 
                $c = [      $z, $z, $z, $z, $z, $z,
                            $z, $z, $z, $z, $z, $z,
                            $z
                ];

                $cd = [      $z, $z, $z, $z, $z, $z,
                            $z, $z, $z, $z, $z, $z,
                            $z
                ];
                $k = [      $z, $z, $z, $z, $z, $z,
                            $z, $z, $z, $z, $z, $z,
                            $z
                ];
                $snorm = [  $z, $z, $z, $z, $z, $z,
                            $z, $z, $z, $z, $z, $z,
                            $z
                ];
                $model = $wmm->wmm;
                // print("<pre>".print_r($model,true)."</pre>");        die;    
            foreach ( $model as $i => $val ) {
                if ( property_exists( (object) $model, $i ) ) {
                    // var_dump('expression');die;
                    if ( $model[ $i ]->m <= $model[ $i ]->n ) {
                        $c[ $model[ $i ]->m ][ $model[ $i ]->n ] = $model[ $i ]->gnm;
                        $cd[ $model[ $i ]->m ][ $model[ $i ]->n ] = $model[ $i ]->dgnm;
                        if ( $model[ $i ]->m != 0 ) {
                            $c[ $model[ $i ]->n ][ $model[ $i ]->m - 1 ] = $model[ $i ]->hnm;
                            $cd[ $model[ $i ]->n ][ $model[ $i ]->m - 1 ] = $model[ $i ]->dhnm;
                        }
                    }
                }
            }
            // var_dump($c);die;

            /* CONVERT SCHMIDT NORMALIZED GAUSS COEFFICIENTS TO UNNORMALIZED */
            $snorm[ 0 ][ 0 ] = 1;

            for ( $n = 1; $n <= $this->maxord; $n++ ) {
                $snorm[ 0 ][ $n ] = $snorm[ 0 ][ $n - 1 ] * ( 2 * $n - 1 ) / $n;
                $j = 2;

                for ( $m = 0, $D2 = ( $n - $m + 1 ); $D2 > 0; $D2--, $m++ ) {
                    $k[ $m ][ $n ] = ( ( ( $n - 1 ) * ( $n - 1 ) ) - ( $m * $m ) ) /
                        ( ( 2 * $n - 1 ) * ( 2 * $n - 3 ) );
                    if ( $m > 0 ) {
                        $flnmj = ( ( $n - $m + 1 ) * $j ) / ( $n + $m );
                        $snorm[ $m ][ $n ] = $snorm[ $m - 1 ][ $n ] * sqrt( $flnmj );
                        $j = 1;
                        $c[ $n ][ $m - 1 ] = $snorm[ $m ][ $n ] * $c[ $n ][ $m - 1 ];
                        $cd[ $n ][ $m - 1 ] = $snorm[ $m ][ $n ] * $cd[ $n ][ $m - 1 ];
                    }
                    $c[ $m ][ $n ] = $snorm[ $m ][ $n ] * $c[ $m ][ $n ];
                    $cd[ $m ][ $n ] = $snorm[ $m ][ $n ] * $cd[ $m ][ $n ];
                }
            }
            // print("<pre>".print_r($c,true)."</pre>");        die;   //same wit js
            // print("<pre>".print_r($cd,true)."</pre>");       die;    //same wit js
            
            $k[ 1 ][ 1 ] = 0.0;
            $epoch = $wmm->epoch;
            
            $this->unnormalizedWMM = (object)[
                'epoch'=> $epoch,
                'k'=> $k,
                'c'=> $c,
                'cd'=> $cd
            ];
            // print("<pre>".print_r($this->unnormalizedWMM,true)."</pre>"); //same wit js
            
        }

        public function setCof ( $cof ) {
            $this->parseCof( $cof );
            $this->unnormalize( $this->wmm );
        }
        public function getWmm () {
            return $this->wmm;
        }
        public function setUnnorm ( $val ) {
            $this->unnormalizedWMM = $val;
        }
        public function getUnnorm () {
            return $this->unnormalizedWMM;
        }
        public function getEpoch () {
            return $this->unnormalizedWMM->epoch;
        }
        public function setEllipsoid ( $e ) {
            $this->a = $e->a;
            $this->b = $e->b;
            $this->re = 6371.2;
            $this->a2 = $this->a * $this->a;
            $this->b2 = $this->b * $this->b;
            $this->c2 = $this->a2 - $this->b2;
            $this->a4 = $this->a2 * $this->a2;
            $this->b4 = $this->b2 * $this->b2;
            $this->c4 = $this->a4 - $this->b4;
        }
        public function getEllipsoid () {
            return (object)[
                 'a'=> $this->a,
                'b'=> $this->b
            ];
        }
        public function calculate ( $glat, $glon, $h, $date=null ) {
            // print("<pre>".print_r($this->unnormalizedWMM,true)."</pre>");
            if ( $this->unnormalizedWMM == null ) { 
                throw new Exception("A World Magnetic Model has not been set.");
            }
            if ( $glat == null || $glon == null ) {
                throw new Exception( "Latitude and longitude are required arguments." );
            }
  
             function decimalDate( $date=null ) {
                if(empty($date)){
                      $date = date('Y-m-d');   
                    }
                $time=strtotime($date);
                $year=(int)date("Y",$time);

                $daysInYear = 365 +
                      ( ( ( $year % 400 == 0 ) || ( $year % 4 == 0 && ( $year % 100 > 0 ) ) ) ? 1 : 0 );
                $msInYear = $daysInYear * 24 * 60 * 60 * 1000;
                $year1 = strtotime($date)*1000 ."<br>";
                $date  = new DateTime($year."-01-01 00:00:00 GMT+0700");

                $year0= $date->getTimestamp() * 1000;
                $yearrt = (float)(( (float)$year1 - (float)$year0 ) / (float)$msInYear);
                // print("<pre>".print_r($year + $yearrt,true)."</pre>") ; //same with js
                return $year + $yearrt;
            }

            function format( $num, $targetLength ) {
                return str_pad($num, $targetLength, "0", STR_PAD_LEFT); 
            }

            $epoch = $this->unnormalizedWMM->epoch;
                $k = $this->unnormalizedWMM->k;
                $c = $this->unnormalizedWMM->c;
                $cd = $this->unnormalizedWMM->cd;
                $alt = isset($h) ? ($h / 3280.8399) : 0; // convert h (in feet) to kilometers (default, 0 km)
                $dt = decimalDate( $date ) - $epoch;
                $rlat = deg2rad( $glat );
                $rlon = deg2rad( $glon );
                $srlon = sin( $rlon );
                $srlat = sin( $rlat );
                $crlon = cos( $rlon );
                $crlat = cos( $rlat );
                $srlat2 = $srlat * $srlat;
                $crlat2 = $crlat * $crlat;
                $q;
                $q1;
                $q2;
                $ct;
                $st;
                $r2;
                $r;
                $d;
                $ca;
                $sa;
                $aor;
                $ar;
                $br = 0.0;
                $bt = 0.0;
                $bp = 0.0;
                $bpp = 0.0;
                $dotx = 0.0;
                $doty = 0.0;
                $dotz = 0.0;
                $par;
                $temp1;
                $temp2;
                $temp3;
                $temp4;
                $parp;
                $D4;
                $m;
                $n;
                $fn = [ 0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ];
                $fm = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ];
                $z = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
                $z = $this->z;
                $tc = [     $z, $z, $z, $z, $z, $z,
                            $z, $z, $z, $z, $z, $z,
                            $z
                ];
                $sp = $z;
                $cp = $z;
                $pp = $z;
                $p = [      $z, $z, $z, $z, $z, $z,
                            $z, $z, $z, $z, $z, $z,
                            $z
                ];

                $dp = [ $z, $z, $z, $z, $z, $z,
                        $z, $z, $z, $z, $z, $z,
                        $z
                ];
                $td = [ $z, $z, $z, $z, $z, $z,
                        $z, $z, $z, $z, $z, $z,
                        $z
                ];
                $te = [ $z, $z, $z, $z, $z, $z,
                        $z, $z, $z, $z, $z, $z,
                            $z
                ];
                $bx;
                $by;
                $bz;
                $bh;
                $ti;
                $dec;
                $dip;
                $dotdecy;
                $dotdecx;
                $gv=0;
            $sp[ 0 ] = 0.0;
            $sp[ 1 ] = $srlon;
            $cp[ 1 ] = $crlon;
            $tc[ 0 ][ 0 ] = 0;
            $td[ 0 ][ 0 ] = 0;
            $te[ 0 ][ 0 ] = 0;
            $cp[ 0 ] = 1.0;
            $pp[ 0 ] = 1.0;
            $p[ 0 ][ 0 ] = 1;

            /* CONVERT FROM GEODETIC COORDS. TO SPHERICAL COORDS. */

            $q = sqrt( $this->a2 - $this->c2 * $srlat2 );
            $q1 = $alt * $q;
            $q2 = ( ( $q1 + $this->a2 ) / ( $q1 + $this->b2 ) ) * ( ( $q1 + $this->a2 ) / ( $q1 + $this->b2 ) );
            $ct = $srlat / sqrt( $q2 * $crlat2 + $srlat2 );
            $st = sqrt( 1.0 - ( $ct * $ct ) );
            $r2 = ( $alt * $alt ) + 2.0 * $q1 + ( $this->a4 - $this->c4 * $srlat2 ) / ( $q * $q );
            $r = sqrt( $r2 );
            $d = sqrt( $this->a2 * $crlat2 + $this->b2 * $srlat2 );
            $ca = ( $alt + $d ) / $r;
            $sa = $this->c2 * $crlat * $srlat / ( $r * $d );
            
            for ( $m = 2; $m <= $this->maxord; $m++ ) {
                $sp[ $m ] = $sp[ 1 ] * $cp[ $m - 1 ] + $cp[ 1 ] * $sp[ $m - 1 ];
                $cp[ $m ] = $cp[ 1 ] * $cp[ $m - 1 ] - $sp[ 1 ] * $sp[ $m - 1 ];
            }

            $aor = $this->re / $r;
            $ar = $aor * $aor;
 
            for ( $n = 1; $n <= $this->maxord; $n++ ) {
                $ar = $ar * $aor;
                for ( $m = 0, $D4 = ( $n + $m + 1 ); $D4 > 0; $D4--, $m++ ) {

                    /*
                            COMPUTE UNNORMALIZED ASSOCIATED LEGENDRE POLYNOMIALS
                            AND DERIVATIVES VIA RECURSION RELATIONS
                    */
                    if ( $n == $m ) {
                        $p[ $m ][ $n ] = $st * $p[ $m - 1 ][ $n - 1 ];
                        $dp[ $m ][ $n ] = $st * $dp[ $m - 1 ][ $n - 1 ] + $ct * $p[ $m - 1 ][ $n - 1 ];
                    } else if ( $n == 1 && $m == 0 ) {
                        $p[ $m ][ $n ] = $ct * $p[ $m ][ $n - 1 ];
                        $dp[ $m ][ $n ] = $ct * $dp[ $m ][ $n - 1 ] - $st * $p[ $m ][ $n - 1 ];
                    } else if ( $n > 1 && $n != $m ) {
                        if ( $m > $n - 2 ) {
                            $p[ $m ][ $n - 2 ] = 0;
                        }
                        if ( $m > $n - 2 ) {
                            $dp[ $m ][ $n - 2 ] = 0.0;
                        }
                        $p[ $m ][ $n ] = $ct * $p[ $m ][ $n - 1 ] - $k[ $m ][ $n ] * $p[ $m ][ $n - 2 ];
                        $dp[ $m ][ $n ] = $ct * $dp[ $m ][ $n - 1 ] - $st * $p[ $m ][ $n - 1 ] - $k[ $m ][ $n ] * $dp[ $m ][ $n - 2 ];
                    } 
                    /*
                            TIME ADJUST THE GAUSS COEFFICIENTS
                    */

                    $tc[ $m ][ $n ] = $c[ $m ][ $n ] + $dt * $cd[ $m ][ $n ];
                    $td[ $m ][ $n ] = $cd[ $m ][ $n ] * $sp[ $m ];
                    $te[ $m ][ $n ] = $cd[ $m ][ $n ] * $cp[ $m ];
                    if ( $m !== 0 ) {
                        $tc[ $n ][ $m - 1 ] = $c[ $n ][ $m - 1 ] + $dt * $cd[ $n ][ $m - 1 ];
                        $td[ $n ][ $m - 1 ] = $cd[ $n ][ $m - 1 ] * $cp[ $m ];
                        $te[ $n ][ $m - 1 ] = $cd[ $n ][ $m - 1 ] * $sp[ $m ];
                    } 
                    /*
                            ACCUMULATE TERMS OF THE SPHERICAL HARMONIC EXPANSIONS
                    */
                    $par = $ar * $p[ $m ][ $n ];
                    if ( $m == 0 ) {
                        $temp1 = $tc[ $m ][ $n ] * $cp[ $m ];
                        $temp2 = $tc[ $m ][ $n ] * $sp[ $m ];
                        $temp3 = $te[ $m ][ $n ];
                        $temp4 = $td[ $m ][ $n ];
                    } else {
                        $temp1 = $tc[ $m ][ $n ] * $cp[ $m ] + $tc[ $n ][ $m - 1 ] * $sp[ $m ];
                        $temp2 = $tc[ $m ][ $n ] * $sp[ $m ] - $tc[ $n ][ $m - 1 ] * $cp[ $m ];
                        $temp3 = $te[ $m ][ $n ] + $te[ $n ][ $m - 1 ];
                        $temp4 = $td[ $m ][ $n ] - $td[ $n ][ $m - 1 ];
                    }
 
                    $dotx += $temp3 * $dp[ $m ][ $n ];
                    $doty += $m * $temp4 * $p[ $m ][ $n ];
                    $dotz += $temp3 * $p[ $m ][ $n ];
                     
                    $bt = $bt - $ar * $temp1 * $dp[ $m ][ $n ];
                    $bp += ( $fm[ $m ] * $temp2 * $par );
                    $br += ( $fn[ $n ] * $temp1 * $par );
           
                    /*
                                SPECIAL CASE:  NORTH/SOUTH GEOGRAPHIC POLES
                    */
                    if ( $st == 0.0 && $m == 1 ) {
                        if ( $n == 1 ) {
                            $pp[ $n ] = $pp[ $n - 1 ];
                        } else {
                            $pp[ $n ] = $ct * $pp[ $n - 1 ] - $k[ $m ][ $n ] * $pp[ $n - 2 ];
                        }
                        $parp = $ar * $pp[ $n ];
                        $bpp += ( $fm[ $m ] * $temp2 * $parp );

                    }

                }
            }
            $bp = (($st == 0.0) ? $bpp : ( $bp / $st ));

            /*
            ROTATE MAGNETIC VECTOR COMPONENTS FROM SPHERICAL TO
            GEODETIC COORDINATES
        */ 
            $bx = -$bt * $ca - $br * $sa;
            $by = $bp;
            $bz = $bt * $sa - $br * $ca;
 
            /*
                COMPUTE DECLINATION (DEC), INCLINATION (DIP) AND
                TOTAL INTENSITY (TI)
            */

            $bh = sqrt( ( $bx * $bx ) + ( $by * $by ) );
            $ti = sqrt( ( $bh * $bh ) + ( $bz * $bz ) );
 
            $dec = rad2deg( atan2( $by, $bx ) );
 
            $dip = rad2deg( atan2( $bz, $bh ) );
 
            $dotx = $dotx * -1.0;
            $doty = $doty / $st;
            $dotz = -1.0 * $dotz;
            $dotdecx = $dotx * $ca - $dotz * $sa;
            if($bh >0){
                        $dotdecy = ( $bx * $doty - $by * $dotdecx ) / pow( $bh, 2 );
                        $dotdecy = rad2deg( $dotdecy );
                    }
 

            /*
                COMPUTE MAGNETIC GRID VARIATION IF THE CURRENT
                GEODETIC POSITION IS IN THE ARCTIC OR ANTARCTIC
                (I.E. GLAT > +55 DEGREES OR GLAT < -55 DEGREES)
                OTHERWISE, SET MAGNETIC GRID VARIATION TO -999.0
            */

            if ( abs( $glat ) >= 55.0 ) {
                if ( $glat > 0.0 && $glon >= 0.0 ) {
                    $gv = $dec - $glon;
                } else if ( $glat > 0.0 && $glon < 0.0 ) {
                    $gv = $dec + abs( $glon );
                } else if ( $glat < 0.0 && $glon >= 0.0 ) {
                    $gv = $dec + $glon;
                } else if ( $glat < 0.0 && $glon < 0.0 ) {
                    $gv = $dec - abs( $glon );
                }
                if ( $gv > 180.0 ) {
                    $gv -= 360.0;
                } else if ( $gv < -180.0 ) {
                    $gv += 360.0;
                }
            }
            
            $mgEW = 'E';
            $EW = '';
            $aip = abs(round($dec));
            $dd = intval( $dec );
            if ( $dec == 0 ) {
                $mgEW = "0°";
                $aip = "0°";
            } else if ( $dec > 0 ) {
                $mgEW = 'E' . format( $dd, 3 ) . format( ( round(  ( $dec - $dd ) * 60 , 1) * 10 ), 3 );
                $aip .= "°E";
                $EW = "E";
            } else if ( $dec < 0 ) {
                $mgEW = 'W' . format( ( $dd * -1 ), 3 ) . format( ( round( ( $dec - $dd ) * -1 * 60 , 1 ) * 10 ), 3 );
                $aip .= "°W";
                $EW = "W";
            }
             
            $time=strtotime($date);
            $yr=(int)date("Y",$time); 
            $month=(int)date("m",$time); 

            $mth = sprintf("%02d", $month);
 
            // var ddy = parseInt( dotdecy )
            $mgEW = $mgEW . ' '. $mth .  substr($yr,-2);
            $aip = $aip . ' (' .  $yr . ')';
            $pyear = '';
            $peryear = '';
            $decinc = '';
            $ddc = $dotdecy;
            // console.log(ddy,dotdecy,ddc)
            if ( $dotdecy > 0 ) {
                $ddc = round( $ddc * 60 );
                $pyear =  round(abs($dotdecy),2) . "°"; // dd + "°" + ( ( dotdecy - ddy ) * 60 ).toFixed()
                $peryear = $pyear + "'E";
                if ( $EW == 'E' ) {
                    $decinc = $pyear . ' Increasing';
                } else {
                    $decinc = $pyear . ' Decreasing';
                }
            } else {
                $pyear =  round(abs($dotdecy),2) . "°"; // ( ddy * -1 ) + "°" + ( ( dotdecy - ddy ) * -1 * 60 ).toFixed()
                $peryear = $pyear . "'W";
                $ddc = round( ( $ddc * 60 ) * -1 );
                if ( $EW == 'E' ) {
                    $decinc = $pyear . ' Decreasing';
                } else {
                    $decinc = $pyear . ' Increasing';
                }
            }
            if ( $ddc == 0 ) {
                $peryear = '0';
            }
            $aip = $aip . ' / ' . $decinc;
 
            // return { dec: dec, magvar: mgEW, tanggal: tgl, dip: dip, ti: ti, bh: bh, bx: bx, by: by, bz: bz, lat: glat, lon: glon, gv: gv };
            $ret = (object)[
                'dec'=> $dec,
                'magvar'=> $mgEW,
                'aip'=> $aip,
                'cy'=> $dotdecy,
                'py'=> $peryear,
                'dip'=> $dip,
                'ti'=> $ti,
                'bh'=> $bh,
                'bx'=> $bx,
                'by'=> $by,
                'bz'=> $bz,
                'lat'=> $glat,
                'lon'=> $glon,
                'gv'=> $gv
            ];
            // var_dump($ret);
            return $ret;
        }
       public function calc ($glat, $glon, $h, $date) {
        return $this->calculate($glat, $glon, $h, $date);
       }
       public function mag ($glat, $glon, $h, $date) {
        return $this->calculate($glat, $glon, $h, $date);
       }
}
/*
how to use Geomag

$newGeomag =  new Geomag();

$myMag = $newGeomag->mag($glat, $glon, $h, $date);  // calculate   

*/  

class GeoidHeights
    {
        private const l_value = 65341;
        private const nmax = 360;

        public $drts;
        public $dirt;
        
        private $cc=[];
        private $cs=[];
        private $hc=[];
        private $hs=[];

        public function __construct(){
            include(app_path() . '/Logic/coef.php');   
            $this->GeoidHeights();
            // var_dump($this->drts);die;
        }
        public function GeoidHeights(){
            $nmx2p = 2 * self::nmax + 1;

            for ($n = 1; $n <= $nmx2p; $n++)
            {
                $this->drts[$n] = sqrt($n);
                $this->dirt[$n] = 1 / $this->drts[$n];
            }
        } 
        public function undulation($degLat, $degLon)
        {
            // var_dump($this->drts);die;   
            $lat = $degLat * pi() / 180;
            $lon = $degLon * pi() / 180;

            $rlat; $gr; $re;
            $i; $j; $m;
            $k = self::nmax + 1;
            $p = array();
            $sinml = array();
            $cosml = array();
            
            $r_ret = self::radgra($lat, $lon);
            // var_dump($r_ret);die;
            $rlat = pi() / 2 - $r_ret['rlat'];
            $rleg = array(361 + 1);

            for ($j = 1; $j <= $k; $j++)
            {
                $m = $j - 1;
                $l_ret = self::legfdn($m, $rlat, $rleg);
                // var_dump($l_ret);die;
                for ($i = $j; $i <= $k; $i++)
                    $p[($i - 1) * $i / 2 + $m + 1] = $l_ret[$i];
            }

            $d_ret = self::dscml($lon, $sinml, $cosml);

            return self::hundu($p, $d_ret['sinml'], $d_ret['cosml'], $r_ret['gr'], $r_ret['re']);
        }

        private static function radgra($lat, $lon)
        /*this subroutine computes geocentric distance to the point,
        the geocentric latitude,and
        an approximate value of normal gravity at the point based
        the constants of the wgs84(g873) system are used*/
        {
            $a = 6378137;
            $e2 = .00669437999013;
            $geqt = 9.7803253359;
            $k = .00193185265246;

            $n;
            $t1 = sin($lat) *sin($lat); $t2; $x; $y; $z;
            $n = $a / sqrt(1 - $e2 * $t1);
            $t2 = $n * cos($lat);
            $x = $t2 * cos($lon);
            $y = $t2 * sin($lon);
            $z = ($n * (1 - $e2)) * sin($lat);
            $re = sqrt($x * $x + $y * $y + $z * $z);/*compute the geocentric radius*/
            $rlat =atan($z / sqrt($x * $x + $y * $y));/*compute the geocentric latitude*/
            $gr = $geqt * (1 + $k * $t1) / sqrt(1 - $e2 * $t1);/*compute normal gravity:units are m/sec**2*/
            $ret =[
                'rlat' => $rlat,
                'gr' => $gr,
                're' => $re
            ];
            return $ret;
        }

        private function legfdn($m, $theta, $rleg)
        /*this subroutine computes  all normalized legendre function
        in "rleg". order is always
        m, and colatitude is always theta  (radians). maximum deg
        is  nmx. all calculations in double precision.
        ir  must be set to zero before the first call to this sub.
        the dimensions of arrays  rleg must be at least equal to  nmx+1.
        Original programmer :Oscar L. Colombo, Dept. of Geodetic Science
        the Ohio State University, August 1980
        ineiev: I removed the derivatives, for they are never computed here*/
        {
            // var_dump($this->drts);die;

            $cothet;
            $sithet;
            $rlnn = array();
            $nmx1 = self::nmax + 1;
            $m1 = $m + 1;
            $m2 = $m + 2;
            $m3 = $m + 3;
            $n; $n1; $n2;

            $cothet = cos($theta);
            $sithet = sin($theta);
            
            /*compute the legendre functions*/
            $rlnn[1] = 1;
            $rlnn[2] = $sithet * $this->drts[3];
            for ($n1 = 3; $n1 <= $m1; $n1++)
            {
                $n = $n1 - 1;
                $n2 = 2 * $n;
                $rlnn[$n1] = $this->drts[$n2 + 1] * $this->dirt[$n2] * $sithet * $rlnn[$n];
            }
            switch ($m)
            {
                case 1:
                    $rleg[2] = $rlnn[2];
                    $rleg[3] = $this->drts[5] * $cothet * $rleg[2];
                    break;
                case 0:
                    $rleg[1] = 1;
                    $rleg[2] = $cothet * $this->drts[3];
                    break;
            }
            $rleg[$m1] = $rlnn[$m1];
            if ($m2 <= $nmx1)
            {
                $rleg[$m2] = $this->drts[$m1 * 2 + 1] * $cothet * $rleg[$m1];
                if ($m3 <= $nmx1)
                    for ($n1 = $m3; $n1 <= $nmx1; $n1++)
                    {
                        $n = $n1 - 1;
                        if (($m == 0 && $n < 2) || ($m == 1 && $n < 3)) continue;
                        $n2 = 2 * $n;
                        $rleg[$n1] = $this->drts[$n2 + 1] * $this->dirt[$n + $m] * $this->dirt[$n - $m] *
                                ($this->drts[$n2 - 1] * $cothet * $rleg[$n1 - 1] - $this->drts[$n + $m - 1] * $this->drts[$n - $m - 1] * $this->dirt[$n2 - 3] * $rleg[$n1 - 2]);
                    }
            }
            return $rleg;
        }

        private function hundu($p, $sinml, $cosml, $gr, $re)
        {
            /*constants for wgs84(g873);gm in units of m**3/s**2*/
            $gm = .3986004418e15;
            $ae = 6378137;
            $arn; $ar; $ac; $a; $sum; $sumc; $tempc; $temp;
            $k; $n ;$m;
            $ar = $ae / $re;
            $arn = $ar;
            $ac = $a = 0;
            $k = 3;
            for ($n = 2; $n <= self::nmax; $n++)
            {
                $arn *= $ar;
                $k++;
                $sum = $p[$k] * $this->hc[$k];
                $sumc = $p[$k] * $this->cs[$k];
                for ($m = 1; $m <= $n; $m++)
                {
                    $k++;
                    $tempc = $this->cs[$k] * $cosml[$m] + $this->cs[$k] * $sinml[$m];
                    $temp = $this->hc[$k] * $cosml[$m] + $this->hs[$k] * $sinml[$m];
                    $sumc += $p[$k] * $tempc;
                    $sum += $p[$k] * $temp;
                }
                $ac += $sumc;
                $a += $sum * $arn;
            }
            $ac += $this->cs[1] + $p[2] * $this->cs[2] + $p[3] * ($this->cs[3] * $cosml[1] + $this->cs[3] * $sinml[1]);
            /*add haco=ac/100 to convert height anomaly on the ellipsoid to the undulation
            add -0.53m to make undulation refer to the wgs84 ellipsoid.*/
            return $a * $gm / ($gr * $re) + $ac / 100 ;//- .53;
        }

        private function dscml($rlon, $sinml, $cosml)
        {
            $a; $b;
            $m;
            $a = sin($rlon);
            $b = cos($rlon);
            $sinml[1] = $a;
            $cosml[1] = $b;
            $sinml[2] = 2 * $b * $a;
            $cosml[2] = 2 * $b * $b - 1;
            for ($m = 3; $m <= self::nmax; $m++)
            {
                $sinml[$m] = 2 * $b * $sinml[$m - 1] - $sinml[$m - 2];
                $cosml[$m] = 2 * $b * $cosml[$m - 1] - $cosml[$m - 2];
            }
            
            $ret =[
                'sinml' => $sinml,
                'cosml' => $cosml,
            ];
            return $ret; 
        }
    }


    /* how to use geoid undulation

    $geoid  = new GeoidHeights();
    $hi= $geoid->undulation(-7.5133269, 110.7470487);
    echo $hi;
    */

    if(!function_exists('GeoHi')){
        function GeoHi($lat, $lon){
            $lat = toDecimal($lat);
            $lon = toDecimal($lon);
            $geoid  = new GeoidHeights();
            $hi= $geoid->undulation($lat, $lon);
            return $hi;                 
        }
    }